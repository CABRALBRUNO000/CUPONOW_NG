{
  "version": 3,
  "sources": ["../../../../../../node_modules/@langchain/core/dist/prompts/base.js", "../../../../../../node_modules/@langchain/core/dist/prompts/string.js", "../../../../../../node_modules/mustache/mustache.mjs", "../../../../../../node_modules/@langchain/core/dist/prompts/template.js", "../../../../../../node_modules/@langchain/core/dist/prompts/prompt.js"],
  "sourcesContent": ["// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { Runnable } from \"../runnables/base.js\";\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nexport class BasePromptTemplate extends Runnable {\n  get lc_attributes() {\n    return {\n      partialVariables: undefined // python doesn't support this yet\n    };\n  }\n  constructor(input) {\n    super(input);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"prompts\", this._getPromptType()]\n    });\n    Object.defineProperty(this, \"inputVariables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"partialVariables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    const {\n      inputVariables\n    } = input;\n    if (inputVariables.includes(\"stop\")) {\n      throw new Error(\"Cannot have an input variable named 'stop', as it is used internally, please rename.\");\n    }\n    Object.assign(this, input);\n  }\n  /**\n   * Merges partial variables and user variables.\n   * @param userVariables The user variables to merge with the partial variables.\n   * @returns A Promise that resolves to an object containing the merged variables.\n   */\n  async mergePartialAndUserVariables(userVariables) {\n    const partialVariables = this.partialVariables ?? {};\n    const partialValues = {};\n    for (const [key, value] of Object.entries(partialVariables)) {\n      if (typeof value === \"string\") {\n        partialValues[key] = value;\n      } else {\n        partialValues[key] = await value();\n      }\n    }\n    const allKwargs = {\n      ...partialValues,\n      ...userVariables\n    };\n    return allKwargs;\n  }\n  /**\n   * Invokes the prompt template with the given input and options.\n   * @param input The input to invoke the prompt template with.\n   * @param options Optional configuration for the callback.\n   * @returns A Promise that resolves to the output of the prompt template.\n   */\n  async invoke(input, options) {\n    return this._callWithConfig(input => this.formatPromptValue(input), input, {\n      ...options,\n      runType: \"prompt\"\n    });\n  }\n  /**\n   * Return a json-like object representing this prompt template.\n   * @deprecated\n   */\n  serialize() {\n    throw new Error(\"Use .toJSON() instead\");\n  }\n  /**\n   * @deprecated\n   * Load a prompt template from a json-like object describing it.\n   *\n   * @remarks\n   * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can\n   * reference remote resources that we read asynchronously with a web\n   * request.\n   */\n  static async deserialize(data) {\n    switch (data._type) {\n      case \"prompt\":\n        {\n          const {\n            PromptTemplate\n          } = await import(\"./prompt.js\");\n          return PromptTemplate.deserialize(data);\n        }\n      case undefined:\n        {\n          const {\n            PromptTemplate\n          } = await import(\"./prompt.js\");\n          return PromptTemplate.deserialize({\n            ...data,\n            _type: \"prompt\"\n          });\n        }\n      case \"few_shot\":\n        {\n          const {\n            FewShotPromptTemplate\n          } = await import(\"./few_shot.js\");\n          return FewShotPromptTemplate.deserialize(data);\n        }\n      default:\n        throw new Error(`Invalid prompt type in config: ${data._type}`);\n    }\n  }\n}", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { StringPromptValue } from \"../prompt_values.js\";\nimport { BasePromptTemplate } from \"./base.js\";\n/**\n * Base class for string prompt templates. It extends the\n * BasePromptTemplate class and overrides the formatPromptValue method to\n * return a StringPromptValue.\n */\nexport class BaseStringPromptTemplate extends BasePromptTemplate {\n  /**\n   * Formats the prompt given the input values and returns a formatted\n   * prompt value.\n   * @param values The input values to format the prompt.\n   * @returns A Promise that resolves to a formatted prompt value.\n   */\n  async formatPromptValue(values) {\n    const formattedPrompt = await this.format(values);\n    return new StringPromptValue(formattedPrompt);\n  }\n}", "/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\nvar objectToString = Object.prototype.toString;\nvar isArray = Array.isArray || function isArrayPolyfill(object) {\n  return objectToString.call(object) === '[object Array]';\n};\nfunction isFunction(object) {\n  return typeof object === 'function';\n}\n\n/**\n * More correct typeof string handling array\n * which normally returns typeof 'object'\n */\nfunction typeStr(obj) {\n  return isArray(obj) ? 'array' : typeof obj;\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n/**\n * Null safe way of checking whether or not an object,\n * including its prototype, has a given property\n */\nfunction hasProperty(obj, propName) {\n  return obj != null && typeof obj === 'object' && propName in obj;\n}\n\n/**\n * Safe way of detecting whether or not the given thing is a primitive and\n * whether it has the given property\n */\nfunction primitiveHasOwnProperty(primitive, propName) {\n  return primitive != null && typeof primitive !== 'object' && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);\n}\n\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n// See https://github.com/janl/mustache.js/issues/189\nvar regExpTest = RegExp.prototype.test;\nfunction testRegExp(re, string) {\n  return regExpTest.call(re, string);\n}\nvar nonSpaceRe = /\\S/;\nfunction isWhitespace(string) {\n  return !testRegExp(nonSpaceRe, string);\n}\nvar entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;'\n};\nfunction escapeHtml(string) {\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap(s) {\n    return entityMap[s];\n  });\n}\nvar whiteRe = /\\s*/;\nvar spaceRe = /\\s+/;\nvar equalsRe = /\\s*=/;\nvar curlyRe = /\\s*\\}/;\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n/**\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\n * argument is given here it must be an array with two string values: the\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n * course, the default is to use mustaches (i.e. mustache.tags).\n *\n * A token is an array with at least 4 elements. The first element is the\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n * all text that appears outside a symbol this element is \"text\".\n *\n * The second element of a token is its \"value\". For mustache tags this is\n * whatever else was inside the tag besides the opening symbol. For text tokens\n * this is the text itself.\n *\n * The third and fourth elements of the token are the start and end indices,\n * respectively, of the token in the original template.\n *\n * Tokens that are the root node of a subtree contain two more elements: 1) an\n * array of tokens in the subtree and 2) the index in the original template at\n * which the closing tag for that section begins.\n *\n * Tokens for partials also contain two more elements: 1) a string value of\n * indendation prior to that tag and 2) the index of that tag on that line -\n * eg a value of 2 indicates the partial is the third tag on this line.\n */\nfunction parseTemplate(template, tags) {\n  if (!template) return [];\n  var lineHasNonSpace = false;\n  var sections = []; // Stack to hold section tokens\n  var tokens = []; // Buffer to hold the tokens\n  var spaces = []; // Indices of whitespace tokens on the current line\n  var hasTag = false; // Is there a {{tag}} on the current line?\n  var nonSpace = false; // Is there a non-space char on the current line?\n  var indentation = ''; // Tracks indentation for tags that use it\n  var tagIndex = 0; // Stores a count of number of tags encountered on a line\n\n  // Strips all whitespace tokens array for the current line\n  // if there was a {{#tag}} on it and otherwise only space.\n  function stripSpace() {\n    if (hasTag && !nonSpace) {\n      while (spaces.length) delete tokens[spaces.pop()];\n    } else {\n      spaces = [];\n    }\n    hasTag = false;\n    nonSpace = false;\n  }\n  var openingTagRe, closingTagRe, closingCurlyRe;\n  function compileTags(tagsToCompile) {\n    if (typeof tagsToCompile === 'string') tagsToCompile = tagsToCompile.split(spaceRe, 2);\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error('Invalid tags: ' + tagsToCompile);\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n  }\n  compileTags(tags || mustache.tags);\n  var scanner = new Scanner(template);\n  var start, type, value, chr, token, openSection;\n  while (!scanner.eos()) {\n    start = scanner.pos;\n\n    // Match any text between tags.\n    value = scanner.scanUntil(openingTagRe);\n    if (value) {\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n        chr = value.charAt(i);\n        if (isWhitespace(chr)) {\n          spaces.push(tokens.length);\n          indentation += chr;\n        } else {\n          nonSpace = true;\n          lineHasNonSpace = true;\n          indentation += ' ';\n        }\n        tokens.push(['text', chr, start, start + 1]);\n        start += 1;\n\n        // Check for whitespace on the current line.\n        if (chr === '\\n') {\n          stripSpace();\n          indentation = '';\n          tagIndex = 0;\n          lineHasNonSpace = false;\n        }\n      }\n    }\n\n    // Match the opening tag.\n    if (!scanner.scan(openingTagRe)) break;\n    hasTag = true;\n\n    // Get the tag type.\n    type = scanner.scan(tagRe) || 'name';\n    scanner.scan(whiteRe);\n\n    // Get the tag value.\n    if (type === '=') {\n      value = scanner.scanUntil(equalsRe);\n      scanner.scan(equalsRe);\n      scanner.scanUntil(closingTagRe);\n    } else if (type === '{') {\n      value = scanner.scanUntil(closingCurlyRe);\n      scanner.scan(curlyRe);\n      scanner.scanUntil(closingTagRe);\n      type = '&';\n    } else {\n      value = scanner.scanUntil(closingTagRe);\n    }\n\n    // Match the closing tag.\n    if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);\n    if (type == '>') {\n      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];\n    } else {\n      token = [type, value, start, scanner.pos];\n    }\n    tagIndex++;\n    tokens.push(token);\n    if (type === '#' || type === '^') {\n      sections.push(token);\n    } else if (type === '/') {\n      // Check section nesting.\n      openSection = sections.pop();\n      if (!openSection) throw new Error('Unopened section \"' + value + '\" at ' + start);\n      if (openSection[1] !== value) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n    } else if (type === 'name' || type === '{' || type === '&') {\n      nonSpace = true;\n    } else if (type === '=') {\n      // Set the tags for the next time around.\n      compileTags(value);\n    }\n  }\n  stripSpace();\n\n  // Make sure there are no open sections when we're done.\n  openSection = sections.pop();\n  if (openSection) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n  return nestTokens(squashTokens(tokens));\n}\n\n/**\n * Combines the values of consecutive text tokens in the given `tokens` array\n * to a single token.\n */\nfunction squashTokens(tokens) {\n  var squashedTokens = [];\n  var token, lastToken;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n    if (token) {\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        squashedTokens.push(token);\n        lastToken = token;\n      }\n    }\n  }\n  return squashedTokens;\n}\n\n/**\n * Forms the given array of `tokens` into a nested tree structure where\n * tokens that represent a section have two additional items: 1) an array of\n * all tokens that appear in that section and 2) the index in the original\n * template that represents the end of that section.\n */\nfunction nestTokens(tokens) {\n  var nestedTokens = [];\n  var collector = nestedTokens;\n  var sections = [];\n  var token, section;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n    switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n    }\n  }\n  return nestedTokens;\n}\n\n/**\n * A simple string scanner that is used by the template parser to find\n * tokens in template strings.\n */\nfunction Scanner(string) {\n  this.string = string;\n  this.tail = string;\n  this.pos = 0;\n}\n\n/**\n * Returns `true` if the tail is empty (end of string).\n */\nScanner.prototype.eos = function eos() {\n  return this.tail === '';\n};\n\n/**\n * Tries to match the given regular expression at the current position.\n * Returns the matched text if it can match, the empty string otherwise.\n */\nScanner.prototype.scan = function scan(re) {\n  var match = this.tail.match(re);\n  if (!match || match.index !== 0) return '';\n  var string = match[0];\n  this.tail = this.tail.substring(string.length);\n  this.pos += string.length;\n  return string;\n};\n\n/**\n * Skips all text until the given regular expression can be matched. Returns\n * the skipped string, which is the entire tail if no match can be made.\n */\nScanner.prototype.scanUntil = function scanUntil(re) {\n  var index = this.tail.search(re),\n    match;\n  switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = '';\n      break;\n    case 0:\n      match = '';\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n  }\n  this.pos += match.length;\n  return match;\n};\n\n/**\n * Represents a rendering context by wrapping a view object and\n * maintaining a reference to the parent context.\n */\nfunction Context(view, parentContext) {\n  this.view = view;\n  this.cache = {\n    '.': this.view\n  };\n  this.parent = parentContext;\n}\n\n/**\n * Creates a new context using the given view with this context\n * as the parent.\n */\nContext.prototype.push = function push(view) {\n  return new Context(view, this);\n};\n\n/**\n * Returns the value of the given name in this context, traversing\n * up the context hierarchy if the value is absent in this context's view.\n */\nContext.prototype.lookup = function lookup(name) {\n  var cache = this.cache;\n  var value;\n  if (cache.hasOwnProperty(name)) {\n    value = cache[name];\n  } else {\n    var context = this,\n      intermediateValue,\n      names,\n      index,\n      lookupHit = false;\n    while (context) {\n      if (name.indexOf('.') > 0) {\n        intermediateValue = context.view;\n        names = name.split('.');\n        index = 0;\n\n        /**\n         * Using the dot notion path in `name`, we descend through the\n         * nested objects.\n         *\n         * To be certain that the lookup has been successful, we have to\n         * check if the last object in the path actually has the property\n         * we are looking for. We store the result in `lookupHit`.\n         *\n         * This is specially necessary for when the value has been set to\n         * `undefined` and we want to avoid looking up parent contexts.\n         *\n         * In the case where dot notation is used, we consider the lookup\n         * to be successful even if the last \"object\" in the path is\n         * not actually an object but a primitive (e.g., a string, or an\n         * integer), because it is sometimes useful to access a property\n         * of an autoboxed primitive, such as the length of a string.\n         **/\n        while (intermediateValue != null && index < names.length) {\n          if (index === names.length - 1) lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);\n          intermediateValue = intermediateValue[names[index++]];\n        }\n      } else {\n        intermediateValue = context.view[name];\n\n        /**\n         * Only checking against `hasProperty`, which always returns `false` if\n         * `context.view` is not an object. Deliberately omitting the check\n         * against `primitiveHasOwnProperty` if dot notation is not used.\n         *\n         * Consider this example:\n         * ```\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n         * ```\n         *\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\n         * in the dot notation case, then render call would return:\n         *\n         * \"The length of a football field is 9.\"\n         *\n         * rather than the expected:\n         *\n         * \"The length of a football field is 100 yards.\"\n         **/\n        lookupHit = hasProperty(context.view, name);\n      }\n      if (lookupHit) {\n        value = intermediateValue;\n        break;\n      }\n      context = context.parent;\n    }\n    cache[name] = value;\n  }\n  if (isFunction(value)) value = value.call(this.view);\n  return value;\n};\n\n/**\n * A Writer knows how to take a stream of tokens and render them to a\n * string, given a context. It also maintains a cache of templates to\n * avoid the need to parse the same template twice.\n */\nfunction Writer() {\n  this.templateCache = {\n    _cache: {},\n    set: function set(key, value) {\n      this._cache[key] = value;\n    },\n    get: function get(key) {\n      return this._cache[key];\n    },\n    clear: function clear() {\n      this._cache = {};\n    }\n  };\n}\n\n/**\n * Clears all cached templates in this writer.\n */\nWriter.prototype.clearCache = function clearCache() {\n  if (typeof this.templateCache !== 'undefined') {\n    this.templateCache.clear();\n  }\n};\n\n/**\n * Parses and caches the given `template` according to the given `tags` or\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n * that is generated from the parse.\n */\nWriter.prototype.parse = function parse(template, tags) {\n  var cache = this.templateCache;\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n  var isCacheEnabled = typeof cache !== 'undefined';\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n  if (tokens == undefined) {\n    tokens = parseTemplate(template, tags);\n    isCacheEnabled && cache.set(cacheKey, tokens);\n  }\n  return tokens;\n};\n\n/**\n * High-level method that is used to render the given `template` with\n * the given `view`.\n *\n * The optional `partials` argument may be an object that contains the\n * names and templates of partials that are used in the template. It may\n * also be a function that is used to load partial templates on the fly\n * that takes a single argument: the name of the partial.\n *\n * If the optional `config` argument is given here, then it should be an\n * object with a `tags` attribute or an `escape` attribute or both.\n * If an array is passed, then it will be interpreted the same way as\n * a `tags` attribute on a `config` object.\n *\n * The `tags` attribute of a `config` object must be an array with two\n * string values: the opening and closing tags used in the template (e.g.\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n *\n * The `escape` attribute of a `config` object must be a function which\n * accepts a string as input and outputs a safely escaped string.\n * If an `escape` function is not provided, then an HTML-safe string\n * escaping function is used as the default.\n */\nWriter.prototype.render = function render(template, view, partials, config) {\n  var tags = this.getConfigTags(config);\n  var tokens = this.parse(template, tags);\n  var context = view instanceof Context ? view : new Context(view, undefined);\n  return this.renderTokens(tokens, context, partials, template, config);\n};\n\n/**\n * Low-level method that renders the given array of `tokens` using\n * the given `context` and `partials`.\n *\n * Note: The `originalTemplate` is only ever used to extract the portion\n * of the original template that was contained in a higher-order section.\n * If the template doesn't use higher-order sections, this argument may\n * be omitted.\n */\nWriter.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {\n  var buffer = '';\n  var token, symbol, value;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    value = undefined;\n    token = tokens[i];\n    symbol = token[0];\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);else if (symbol === '>') value = this.renderPartial(token, context, partials, config);else if (symbol === '&') value = this.unescapedValue(token, context);else if (symbol === 'name') value = this.escapedValue(token, context, config);else if (symbol === 'text') value = this.rawValue(token);\n    if (value !== undefined) buffer += value;\n  }\n  return buffer;\n};\nWriter.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {\n  var self = this;\n  var buffer = '';\n  var value = context.lookup(token[1]);\n\n  // This function is used to render an arbitrary template\n  // in the current context by higher-order sections.\n  function subRender(template) {\n    return self.render(template, context, partials, config);\n  }\n  if (!value) return;\n  if (isArray(value)) {\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n    }\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n  } else if (isFunction(value)) {\n    if (typeof originalTemplate !== 'string') throw new Error('Cannot use higher-order sections without the original template');\n\n    // Extract the portion of the original template that the section contains.\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n    if (value != null) buffer += value;\n  } else {\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n  }\n  return buffer;\n};\nWriter.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {\n  var value = context.lookup(token[1]);\n\n  // Use JavaScript's definition of falsy. Include empty arrays.\n  // See https://github.com/janl/mustache.js/issues/186\n  if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate, config);\n};\nWriter.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n  var partialByNl = partial.split('\\n');\n  for (var i = 0; i < partialByNl.length; i++) {\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n      partialByNl[i] = filteredIndentation + partialByNl[i];\n    }\n  }\n  return partialByNl.join('\\n');\n};\nWriter.prototype.renderPartial = function renderPartial(token, context, partials, config) {\n  if (!partials) return;\n  var tags = this.getConfigTags(config);\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n  if (value != null) {\n    var lineHasNonSpace = token[6];\n    var tagIndex = token[5];\n    var indentation = token[4];\n    var indentedValue = value;\n    if (tagIndex == 0 && indentation) {\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n    }\n    var tokens = this.parse(indentedValue, tags);\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\n  }\n};\nWriter.prototype.unescapedValue = function unescapedValue(token, context) {\n  var value = context.lookup(token[1]);\n  if (value != null) return value;\n};\nWriter.prototype.escapedValue = function escapedValue(token, context, config) {\n  var escape = this.getConfigEscape(config) || mustache.escape;\n  var value = context.lookup(token[1]);\n  if (value != null) return typeof value === 'number' && escape === mustache.escape ? String(value) : escape(value);\n};\nWriter.prototype.rawValue = function rawValue(token) {\n  return token[1];\n};\nWriter.prototype.getConfigTags = function getConfigTags(config) {\n  if (isArray(config)) {\n    return config;\n  } else if (config && typeof config === 'object') {\n    return config.tags;\n  } else {\n    return undefined;\n  }\n};\nWriter.prototype.getConfigEscape = function getConfigEscape(config) {\n  if (config && typeof config === 'object' && !isArray(config)) {\n    return config.escape;\n  } else {\n    return undefined;\n  }\n};\nvar mustache = {\n  name: 'mustache.js',\n  version: '4.2.0',\n  tags: ['{{', '}}'],\n  clearCache: undefined,\n  escape: undefined,\n  parse: undefined,\n  render: undefined,\n  Scanner: undefined,\n  Context: undefined,\n  Writer: undefined,\n  /**\n   * Allows a user to override the default caching strategy, by providing an\n   * object with set, get and clear methods. This can also be used to disable\n   * the cache by setting it to the literal `undefined`.\n   */\n  set templateCache(cache) {\n    defaultWriter.templateCache = cache;\n  },\n  /**\n   * Gets the default or overridden caching object from the default writer.\n   */\n  get templateCache() {\n    return defaultWriter.templateCache;\n  }\n};\n\n// All high-level mustache.* functions use this writer.\nvar defaultWriter = new Writer();\n\n/**\n * Clears all cached templates in the default writer.\n */\nmustache.clearCache = function clearCache() {\n  return defaultWriter.clearCache();\n};\n\n/**\n * Parses and caches the given template in the default writer and returns the\n * array of tokens it contains. Doing this ahead of time avoids the need to\n * parse templates on the fly as they are rendered.\n */\nmustache.parse = function parse(template, tags) {\n  return defaultWriter.parse(template, tags);\n};\n\n/**\n * Renders the `template` with the given `view`, `partials`, and `config`\n * using the default writer.\n */\nmustache.render = function render(template, view, partials, config) {\n  if (typeof template !== 'string') {\n    throw new TypeError('Invalid template! Template should be a \"string\" ' + 'but \"' + typeStr(template) + '\" was given as the first ' + 'argument for mustache#render(template, view, partials)');\n  }\n  return defaultWriter.render(template, view, partials, config);\n};\n\n// Export the escaping function so that the user may override it.\n// See https://github.com/janl/mustache.js/issues/244\nmustache.escape = escapeHtml;\n\n// Export these mainly for testing, but also for advanced usage.\nmustache.Scanner = Scanner;\nmustache.Context = Context;\nmustache.Writer = Writer;\nexport default mustache;", "import mustache from \"mustache\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\nfunction configureMustache() {\n  // Use unescaped HTML\n  // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n  mustache.escape = text => text;\n}\nexport const parseFString = template => {\n  // Core logic replicated from internals of pythons built in Formatter class.\n  // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n  const chars = template.split(\"\");\n  const nodes = [];\n  const nextBracket = (bracket, start) => {\n    for (let i = start; i < chars.length; i += 1) {\n      if (bracket.includes(chars[i])) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  let i = 0;\n  while (i < chars.length) {\n    if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n      nodes.push({\n        type: \"literal\",\n        text: \"{\"\n      });\n      i += 2;\n    } else if (chars[i] === \"}\" && i + 1 < chars.length && chars[i + 1] === \"}\") {\n      nodes.push({\n        type: \"literal\",\n        text: \"}\"\n      });\n      i += 2;\n    } else if (chars[i] === \"{\") {\n      const j = nextBracket(\"}\", i);\n      if (j < 0) {\n        throw new Error(\"Unclosed '{' in template.\");\n      }\n      nodes.push({\n        type: \"variable\",\n        name: chars.slice(i + 1, j).join(\"\")\n      });\n      i = j + 1;\n    } else if (chars[i] === \"}\") {\n      throw new Error(\"Single '}' in template.\");\n    } else {\n      const next = nextBracket(\"{}\", i);\n      const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n      nodes.push({\n        type: \"literal\",\n        text\n      });\n      i = next < 0 ? chars.length : next;\n    }\n  }\n  return nodes;\n};\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = template => template.map(temp => {\n  if (temp[0] === \"name\") {\n    const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n    return {\n      type: \"variable\",\n      name\n    };\n  } else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n    // # represents a section, \"&\" represents an unescaped variable.\n    // These should both be considered variables.\n    return {\n      type: \"variable\",\n      name: temp[1]\n    };\n  } else {\n    return {\n      type: \"literal\",\n      text: temp[1]\n    };\n  }\n});\nexport const parseMustache = template => {\n  configureMustache();\n  const parsed = mustache.parse(template);\n  return mustacheTemplateToNodes(parsed);\n};\nexport const interpolateFString = (template, values) => {\n  return parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n      if (node.name in values) {\n        const stringValue = typeof values[node.name] === \"string\" ? values[node.name] : JSON.stringify(values[node.name]);\n        return res + stringValue;\n      }\n      throw new Error(`(f-string) Missing value for input ${node.name}`);\n    }\n    return res + node.text;\n  }, \"\");\n};\nexport const interpolateMustache = (template, values) => {\n  configureMustache();\n  return mustache.render(template, values);\n};\nexport const DEFAULT_FORMATTER_MAPPING = {\n  \"f-string\": interpolateFString,\n  mustache: interpolateMustache\n};\nexport const DEFAULT_PARSER_MAPPING = {\n  \"f-string\": parseFString,\n  mustache: parseMustache\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => {\n  try {\n    return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n  } catch (e) {\n    const error = addLangChainErrorFields(e, \"INVALID_PROMPT_INPUT\");\n    throw error;\n  }\n};\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n  if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n    const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n    throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n  }\n  try {\n    const dummyInputs = inputVariables.reduce((acc, v) => {\n      acc[v] = \"foo\";\n      return acc;\n    }, {});\n    if (Array.isArray(template)) {\n      template.forEach(message => {\n        if (message.type === \"text\") {\n          renderTemplate(message.text, templateFormat, dummyInputs);\n        } else if (message.type === \"image_url\") {\n          if (typeof message.image_url === \"string\") {\n            renderTemplate(message.image_url, templateFormat, dummyInputs);\n          } else {\n            const imageUrl = message.image_url.url;\n            renderTemplate(imageUrl, templateFormat, dummyInputs);\n          }\n        } else {\n          throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);\n        }\n      });\n    } else {\n      renderTemplate(template, templateFormat, dummyInputs);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e) {\n    throw new Error(`Invalid prompt schema: ${e.message}`);\n  }\n};", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n  static lc_name() {\n    return \"PromptTemplate\";\n  }\n  constructor(input) {\n    super(input);\n    Object.defineProperty(this, \"template\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"templateFormat\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"f-string\"\n    });\n    Object.defineProperty(this, \"validateTemplate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    /**\n     * Additional fields which should be included inside\n     * the message content array if using a complex message\n     * content.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"additionalContentFields\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // If input is mustache and validateTemplate is not defined, set it to false\n    if (input.templateFormat === \"mustache\" && input.validateTemplate === undefined) {\n      this.validateTemplate = false;\n    }\n    Object.assign(this, input);\n    if (this.validateTemplate) {\n      if (this.templateFormat === \"mustache\") {\n        throw new Error(\"Mustache templates cannot be validated.\");\n      }\n      let totalInputVariables = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n      }\n      checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n    }\n  }\n  _getPromptType() {\n    return \"prompt\";\n  }\n  /**\n   * Formats the prompt template with the provided values.\n   * @param values The values to be used to format the prompt template.\n   * @returns A promise that resolves to a string which is the formatted prompt.\n   */\n  async format(values) {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    return renderTemplate(this.template, this.templateFormat, allValues);\n  }\n  /**\n   * Take examples in list format with prefix and suffix to create a prompt.\n   *\n   * Intended to be used a a way to dynamically create a prompt from examples.\n   *\n   * @param examples - List of examples to use in the prompt.\n   * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n   * @param inputVariables - A list of variable names the final prompt template will expect\n   * @param exampleSeparator - The separator to use in between examples\n   * @param prefix - String that should go before any examples. Generally includes examples.\n   *\n   * @returns The final prompt template generated.\n   */\n  static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n    const template = [prefix, ...examples, suffix].join(exampleSeparator);\n    return new PromptTemplate({\n      inputVariables,\n      template\n    });\n  }\n  static fromTemplate(template, options) {\n    const {\n      templateFormat = \"f-string\",\n      ...rest\n    } = options ?? {};\n    const names = new Set();\n    parseTemplate(template, templateFormat).forEach(node => {\n      if (node.type === \"variable\") {\n        names.add(node.name);\n      }\n    });\n    return new PromptTemplate({\n      // Rely on extracted types\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      inputVariables: [...names],\n      templateFormat,\n      template,\n      ...rest\n    });\n  }\n  /**\n   * Partially applies values to the prompt template.\n   * @param values The values to be partially applied to the prompt template.\n   * @returns A new instance of PromptTemplate with the partially applied values.\n   */\n  async partial(values) {\n    const newInputVariables = this.inputVariables.filter(iv => !(iv in values));\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values\n    };\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables\n    };\n    return new PromptTemplate(promptDict);\n  }\n  serialize() {\n    if (this.outputParser !== undefined) {\n      throw new Error(\"Cannot serialize a prompt template with an output parser\");\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      template: this.template,\n      template_format: this.templateFormat\n    };\n  }\n  static async deserialize(data) {\n    if (!data.template) {\n      throw new Error(\"Prompt template must have a template\");\n    }\n    const res = new PromptTemplate({\n      inputVariables: data.input_variables,\n      template: data.template,\n      templateFormat: data.template_format\n    });\n    return res;\n  }\n}"],
  "mappings": "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",
  "names": ["input", "PromptTemplate", "clearCache", "parse", "render", "i", "parseTemplate", "parseTemplate"]
}
