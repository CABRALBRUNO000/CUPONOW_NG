{
  "version": 3,
  "sources": ["../../../../../../node_modules/langchain/dist/output_parsers/noop.js", "../../../../../../node_modules/langchain/dist/chains/llm_chain.js"],
  "sourcesContent": ["import { BaseOutputParser } from \"@langchain/core/output_parsers\";\n/**\n * The NoOpOutputParser class is a type of output parser that does not\n * perform any operations on the output. It extends the BaseOutputParser\n * class and is part of the LangChain's output parsers module. This class\n * is useful in scenarios where the raw output of the Large Language\n * Models (LLMs) is required.\n */\nexport class NoOpOutputParser extends BaseOutputParser {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"default\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  static lc_name() {\n    return \"NoOpOutputParser\";\n  }\n  /**\n   * This method takes a string as input and returns the same string as\n   * output. It does not perform any operations on the input string.\n   * @param text The input string to be parsed.\n   * @returns The same input string without any operations performed on it.\n   */\n  parse(text) {\n    return Promise.resolve(text);\n  }\n  /**\n   * This method returns an empty string. It does not provide any formatting\n   * instructions.\n   * @returns An empty string, indicating no formatting instructions.\n   */\n  getFormatInstructions() {\n    return \"\";\n  }\n}", "import { BaseLanguageModel } from \"@langchain/core/language_models/base\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { Runnable } from \"@langchain/core/runnables\";\nimport { BaseChain } from \"./base.js\";\nimport { NoOpOutputParser } from \"../output_parsers/noop.js\";\nfunction isBaseLanguageModel(llmLike) {\n  return typeof llmLike._llmType === \"function\";\n}\nfunction _getLanguageModel(llmLike) {\n  if (isBaseLanguageModel(llmLike)) {\n    return llmLike;\n  } else if (\"bound\" in llmLike && Runnable.isRunnable(llmLike.bound)) {\n    return _getLanguageModel(llmLike.bound);\n  } else if (\"runnable\" in llmLike && \"fallbacks\" in llmLike && Runnable.isRunnable(llmLike.runnable)) {\n    return _getLanguageModel(llmLike.runnable);\n  } else if (\"default\" in llmLike && Runnable.isRunnable(llmLike.default)) {\n    return _getLanguageModel(llmLike.default);\n  } else {\n    throw new Error(\"Unable to extract BaseLanguageModel from llmLike object.\");\n  }\n}\n/**\n * @deprecated This class will be removed in 1.0.0. Use the LangChain Expression Language (LCEL) instead.\n * See the example below for how to use LCEL with the LLMChain class:\n *\n * Chain to run queries against LLMs.\n *\n * @example\n * ```ts\n * import { ChatPromptTemplate } from \"@langchain/core/prompts\";\n * import { ChatOpenAI } from \"@langchain/openai\";\n *\n * const prompt = ChatPromptTemplate.fromTemplate(\"Tell me a {adjective} joke\");\n * const llm = new ChatOpenAI();\n * const chain = prompt.pipe(llm);\n *\n * const response = await chain.invoke({ adjective: \"funny\" });\n * ```\n */\nexport class LLMChain extends BaseChain {\n  static lc_name() {\n    return \"LLMChain\";\n  }\n  get inputKeys() {\n    return this.prompt.inputVariables;\n  }\n  get outputKeys() {\n    return [this.outputKey];\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"prompt\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"llm\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"llmKwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"text\"\n    });\n    Object.defineProperty(this, \"outputParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.prompt = fields.prompt;\n    this.llm = fields.llm;\n    this.llmKwargs = fields.llmKwargs;\n    this.outputKey = fields.outputKey ?? this.outputKey;\n    this.outputParser = fields.outputParser ?? new NoOpOutputParser();\n    if (this.prompt.outputParser) {\n      if (fields.outputParser) {\n        throw new Error(\"Cannot set both outputParser and prompt.outputParser\");\n      }\n      this.outputParser = this.prompt.outputParser;\n    }\n  }\n  getCallKeys() {\n    const callKeys = \"callKeys\" in this.llm ? this.llm.callKeys : [];\n    return callKeys;\n  }\n  /** @ignore */\n  _selectMemoryInputs(values) {\n    const valuesForMemory = super._selectMemoryInputs(values);\n    const callKeys = this.getCallKeys();\n    for (const key of callKeys) {\n      if (key in values) {\n        delete valuesForMemory[key];\n      }\n    }\n    return valuesForMemory;\n  }\n  /** @ignore */\n  async _getFinalOutput(generations, promptValue, runManager) {\n    let finalCompletion;\n    if (this.outputParser) {\n      finalCompletion = await this.outputParser.parseResultWithPrompt(generations, promptValue, runManager?.getChild());\n    } else {\n      finalCompletion = generations[0].text;\n    }\n    return finalCompletion;\n  }\n  /**\n   * Run the core logic of this chain and add to output if desired.\n   *\n   * Wraps _call and handles memory.\n   */\n  call(values, config) {\n    return super.call(values, config);\n  }\n  /** @ignore */\n  async _call(values, runManager) {\n    const valuesForPrompt = {\n      ...values\n    };\n    const valuesForLLM = {\n      ...this.llmKwargs\n    };\n    const callKeys = this.getCallKeys();\n    for (const key of callKeys) {\n      if (key in values) {\n        if (valuesForLLM) {\n          valuesForLLM[key] = values[key];\n          delete valuesForPrompt[key];\n        }\n      }\n    }\n    const promptValue = await this.prompt.formatPromptValue(valuesForPrompt);\n    if (\"generatePrompt\" in this.llm) {\n      const {\n        generations\n      } = await this.llm.generatePrompt([promptValue], valuesForLLM, runManager?.getChild());\n      return {\n        [this.outputKey]: await this._getFinalOutput(generations[0], promptValue, runManager)\n      };\n    }\n    const modelWithParser = this.outputParser ? this.llm.pipe(this.outputParser) : this.llm;\n    const response = await modelWithParser.invoke(promptValue, runManager?.getChild());\n    return {\n      [this.outputKey]: response\n    };\n  }\n  /**\n   * Format prompt with values and pass to LLM\n   *\n   * @param values - keys to pass to prompt template\n   * @param callbackManager - CallbackManager to use\n   * @returns Completion from LLM.\n   *\n   * @example\n   * ```ts\n   * llm.predict({ adjective: \"funny\" })\n   * ```\n   */\n  async predict(values, callbackManager) {\n    const output = await this.call(values, callbackManager);\n    return output[this.outputKey];\n  }\n  _chainType() {\n    return \"llm\";\n  }\n  static async deserialize(data) {\n    const {\n      llm,\n      prompt\n    } = data;\n    if (!llm) {\n      throw new Error(\"LLMChain must have llm\");\n    }\n    if (!prompt) {\n      throw new Error(\"LLMChain must have prompt\");\n    }\n    return new LLMChain({\n      llm: await BaseLanguageModel.deserialize(llm),\n      prompt: await BasePromptTemplate.deserialize(prompt)\n    });\n  }\n  /** @deprecated */\n  serialize() {\n    const serialize = \"serialize\" in this.llm ? this.llm.serialize() : undefined;\n    return {\n      _type: `${this._chainType()}_chain`,\n      llm: serialize,\n      prompt: this.prompt.serialize()\n    };\n  }\n  _getNumTokens(text) {\n    return _getLanguageModel(this.llm).getNumTokens(text);\n  }\n}"],
  "mappings": "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",
  "names": []
}
