{
  "version": 3,
  "sources": ["../../../../../../node_modules/@langchain/core/dist/prompts/pipeline.js", "../../../../../../node_modules/@langchain/core/dist/prompts/structured.js"],
  "sourcesContent": ["import { BasePromptTemplate } from \"./base.js\";\nimport { ChatPromptTemplate } from \"./chat.js\";\n/**\n * Class that handles a sequence of prompts, each of which may require\n * different input variables. Includes methods for formatting these\n * prompts, extracting required input values, and handling partial\n * prompts.\n * @example\n * ```typescript\n * const composedPrompt = new PipelinePromptTemplate({\n *   pipelinePrompts: [\n *     {\n *       name: \"introduction\",\n *       prompt: PromptTemplate.fromTemplate(`You are impersonating {person}.`),\n *     },\n *     {\n *       name: \"example\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Here's an example of an interaction:\n * Q: {example_q}\n * A: {example_a}`,\n *       ),\n *     },\n *     {\n *       name: \"start\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Now, do this for real!\n * Q: {input}\n * A:`,\n *       ),\n *     },\n *   ],\n *   finalPrompt: PromptTemplate.fromTemplate(\n *     `{introduction}\n * {example}\n * {start}`,\n *   ),\n * });\n *\n * const formattedPrompt = await composedPrompt.format({\n *   person: \"Elon Musk\",\n *   example_q: `What's your favorite car?`,\n *   example_a: \"Tesla\",\n *   input: `What's your favorite social media site?`,\n * });\n * ```\n */\nexport class PipelinePromptTemplate extends BasePromptTemplate {\n  static lc_name() {\n    return \"PipelinePromptTemplate\";\n  }\n  constructor(input) {\n    super({\n      ...input,\n      inputVariables: []\n    });\n    Object.defineProperty(this, \"pipelinePrompts\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"finalPrompt\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.pipelinePrompts = input.pipelinePrompts;\n    this.finalPrompt = input.finalPrompt;\n    this.inputVariables = this.computeInputValues();\n  }\n  /**\n   * Computes the input values required by the pipeline prompts.\n   * @returns Array of input values required by the pipeline prompts.\n   */\n  computeInputValues() {\n    const intermediateValues = this.pipelinePrompts.map(pipelinePrompt => pipelinePrompt.name);\n    const inputValues = this.pipelinePrompts.map(pipelinePrompt => pipelinePrompt.prompt.inputVariables.filter(inputValue => !intermediateValues.includes(inputValue))).flat();\n    return [...new Set(inputValues)];\n  }\n  static extractRequiredInputValues(allValues, requiredValueNames) {\n    return requiredValueNames.reduce((requiredValues, valueName) => {\n      // eslint-disable-next-line no-param-reassign\n      requiredValues[valueName] = allValues[valueName];\n      return requiredValues;\n    }, {});\n  }\n  /**\n   * Formats the pipeline prompts based on the provided input values.\n   * @param values Input values to format the pipeline prompts.\n   * @returns Promise that resolves with the formatted input values.\n   */\n  async formatPipelinePrompts(values) {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    for (const {\n      name: pipelinePromptName,\n      prompt: pipelinePrompt\n    } of this.pipelinePrompts) {\n      const pipelinePromptInputValues = PipelinePromptTemplate.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (pipelinePrompt instanceof ChatPromptTemplate) {\n        allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);\n      } else {\n        allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);\n      }\n    }\n    return PipelinePromptTemplate.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);\n  }\n  /**\n   * Formats the final prompt value based on the provided input values.\n   * @param values Input values to format the final prompt value.\n   * @returns Promise that resolves with the formatted final prompt value.\n   */\n  async formatPromptValue(values) {\n    return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));\n  }\n  async format(values) {\n    return this.finalPrompt.format(await this.formatPipelinePrompts(values));\n  }\n  /**\n   * Handles partial prompts, which are prompts that have been partially\n   * filled with input values.\n   * @param values Partial input values.\n   * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.\n   */\n  async partial(values) {\n    const promptDict = {\n      ...this\n    };\n    promptDict.inputVariables = this.inputVariables.filter(iv => !(iv in values));\n    promptDict.partialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values\n    };\n    return new PipelinePromptTemplate(promptDict);\n  }\n  serialize() {\n    throw new Error(\"Not implemented.\");\n  }\n  _getPromptType() {\n    return \"pipeline\";\n  }\n}", "import { ChatPromptTemplate } from \"./chat.js\";\nfunction isWithStructuredOutput(x\n// eslint-disable-next-line @typescript-eslint/ban-types\n) {\n  return typeof x === \"object\" && x != null && \"withStructuredOutput\" in x && typeof x.withStructuredOutput === \"function\";\n}\nfunction isRunnableBinding(x) {\n  return typeof x === \"object\" && x != null && \"lc_id\" in x && Array.isArray(x.lc_id) && x.lc_id.join(\"/\") === \"langchain_core/runnables/RunnableBinding\";\n}\nexport class StructuredPrompt extends ChatPromptTemplate {\n  get lc_aliases() {\n    return {\n      ...super.lc_aliases,\n      schema: \"schema_\"\n    };\n  }\n  constructor(input) {\n    super(input);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"prompts\", \"structured\"]\n    });\n    this.schema = input.schema;\n  }\n  pipe(coerceable) {\n    if (isWithStructuredOutput(coerceable)) {\n      return super.pipe(coerceable.withStructuredOutput(this.schema));\n    }\n    if (isRunnableBinding(coerceable) && isWithStructuredOutput(coerceable.bound)) {\n      return super.pipe(coerceable.bound.withStructuredOutput(this.schema).bind(coerceable.kwargs ?? {}).withConfig(coerceable.config));\n    }\n    throw new Error(`Structured prompts need to be piped to a language model that supports the \"withStructuredOutput()\" method.`);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromMessagesAndSchema(promptMessages, schema\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    return StructuredPrompt.fromMessages(promptMessages, {\n      schema\n    });\n  }\n}"],
  "mappings": "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",
  "names": []
}
