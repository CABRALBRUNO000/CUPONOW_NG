{
  "version": 3,
  "sources": ["../../../../../../node_modules/langchain/dist/util/set.js", "../../../../../../node_modules/langchain/dist/chains/sequential_chain.js"],
  "sourcesContent": ["/**\n * Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#implementing_basic_set_operations\n */\n/**\n * returns intersection of two sets\n */\nexport function intersection(setA, setB) {\n  const _intersection = new Set();\n  for (const elem of setB) {\n    if (setA.has(elem)) {\n      _intersection.add(elem);\n    }\n  }\n  return _intersection;\n}\n/**\n * returns union of two sets\n */\nexport function union(setA, setB) {\n  const _union = new Set(setA);\n  for (const elem of setB) {\n    _union.add(elem);\n  }\n  return _union;\n}\n/**\n * returns difference of two sets\n */\nexport function difference(setA, setB) {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}", "import { BaseChain } from \"./base.js\";\nimport { intersection, union, difference } from \"../util/set.js\";\nfunction formatSet(input) {\n  return Array.from(input).map(i => `\"${i}\"`).join(\", \");\n}\n/**\n * Chain where the outputs of one chain feed directly into next.\n * @example\n * ```typescript\n * const promptTemplate = new PromptTemplate({\n *   template: `You are a playwright. Given the title of play and the era it is set in, it is your job to write a synopsis for that title.\n * Title: {title}\n * Era: {era}\n * Playwright: This is a synopsis for the above play:`,\n *   inputVariables: [\"title\", \"era\"],\n * });\n\n * const reviewPromptTemplate = new PromptTemplate({\n *   template: `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\n *\n *     Play Synopsis:\n *     {synopsis}\n *     Review from a New York Times play critic of the above play:`,\n *   inputVariables: [\"synopsis\"],\n * });\n\n * const overallChain = new SequentialChain({\n *   chains: [\n *     new LLMChain({\n *       llm: new ChatOpenAI({ temperature: 0 }),\n *       prompt: promptTemplate,\n *       outputKey: \"synopsis\",\n *     }),\n *     new LLMChain({\n *       llm: new OpenAI({ temperature: 0 }),\n *       prompt: reviewPromptTemplate,\n *       outputKey: \"review\",\n *     }),\n *   ],\n *   inputVariables: [\"era\", \"title\"],\n *   outputVariables: [\"synopsis\", \"review\"],\n *   verbose: true,\n * });\n\n * const chainExecutionResult = await overallChain.call({\n *   title: \"Tragedy at sunset on the beach\",\n *   era: \"Victorian England\",\n * });\n * console.log(chainExecutionResult);\n * ```\n *\n * @deprecated\n * Switch to {@link https://js.langchain.com/docs/expression_language/ | expression language}.\n * Will be removed in 0.2.0\n */\nexport class SequentialChain extends BaseChain {\n  static lc_name() {\n    return \"SequentialChain\";\n  }\n  get inputKeys() {\n    return this.inputVariables;\n  }\n  get outputKeys() {\n    return this.outputVariables;\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"chains\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputVariables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputVariables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"returnAll\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.chains = fields.chains;\n    this.inputVariables = fields.inputVariables;\n    this.outputVariables = fields.outputVariables ?? [];\n    if (this.outputVariables.length > 0 && fields.returnAll) {\n      throw new Error(\"Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.\");\n    }\n    this.returnAll = fields.returnAll ?? false;\n    this._validateChains();\n  }\n  /** @ignore */\n  _validateChains() {\n    if (this.chains.length === 0) {\n      throw new Error(\"Sequential chain must have at least one chain.\");\n    }\n    const memoryKeys = this.memory?.memoryKeys ?? [];\n    const inputKeysSet = new Set(this.inputKeys);\n    const memoryKeysSet = new Set(memoryKeys);\n    const keysIntersection = intersection(inputKeysSet, memoryKeysSet);\n    if (keysIntersection.size > 0) {\n      throw new Error(`The following keys: ${formatSet(keysIntersection)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);\n    }\n    const availableKeys = union(inputKeysSet, memoryKeysSet);\n    for (const chain of this.chains) {\n      let missingKeys = difference(new Set(chain.inputKeys), availableKeys);\n      if (chain.memory) {\n        missingKeys = difference(missingKeys, new Set(chain.memory.memoryKeys));\n      }\n      if (missingKeys.size > 0) {\n        throw new Error(`Missing variables for chain \"${chain._chainType()}\": ${formatSet(missingKeys)}. Only got the following variables: ${formatSet(availableKeys)}.`);\n      }\n      const outputKeysSet = new Set(chain.outputKeys);\n      const overlappingOutputKeys = intersection(availableKeys, outputKeysSet);\n      if (overlappingOutputKeys.size > 0) {\n        throw new Error(`The following output variables for chain \"${chain._chainType()}\" are overlapping: ${formatSet(overlappingOutputKeys)}. This can lead to unexpected behaviour.`);\n      }\n      for (const outputKey of outputKeysSet) {\n        availableKeys.add(outputKey);\n      }\n    }\n    if (this.outputVariables.length === 0) {\n      if (this.returnAll) {\n        const outputKeys = difference(availableKeys, inputKeysSet);\n        this.outputVariables = Array.from(outputKeys);\n      } else {\n        this.outputVariables = this.chains[this.chains.length - 1].outputKeys;\n      }\n    } else {\n      const missingKeys = difference(new Set(this.outputVariables), new Set(availableKeys));\n      if (missingKeys.size > 0) {\n        throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${formatSet(missingKeys)}.`);\n      }\n    }\n  }\n  /** @ignore */\n  async _call(values, runManager) {\n    let input = {};\n    const allChainValues = values;\n    let i = 0;\n    for (const chain of this.chains) {\n      i += 1;\n      input = await chain.call(allChainValues, runManager?.getChild(`step_${i}`));\n      for (const key of Object.keys(input)) {\n        allChainValues[key] = input[key];\n      }\n    }\n    const output = {};\n    for (const key of this.outputVariables) {\n      output[key] = allChainValues[key];\n    }\n    return output;\n  }\n  _chainType() {\n    return \"sequential_chain\";\n  }\n  static async deserialize(data) {\n    const chains = [];\n    const inputVariables = data.input_variables;\n    const outputVariables = data.output_variables;\n    const serializedChains = data.chains;\n    for (const serializedChain of serializedChains) {\n      const deserializedChain = await BaseChain.deserialize(serializedChain);\n      chains.push(deserializedChain);\n    }\n    return new SequentialChain({\n      chains,\n      inputVariables,\n      outputVariables\n    });\n  }\n  serialize() {\n    const chains = [];\n    for (const chain of this.chains) {\n      chains.push(chain.serialize());\n    }\n    return {\n      _type: this._chainType(),\n      input_variables: this.inputVariables,\n      output_variables: this.outputVariables,\n      chains\n    };\n  }\n}\n/**\n * @deprecated Switch to expression language: https://js.langchain.com/docs/expression_language/\n * Simple chain where a single string output of one chain is fed directly into the next.\n * @augments BaseChain\n * @augments SimpleSequentialChainInput\n *\n * @example\n * ```ts\n * import { SimpleSequentialChain, LLMChain } from \"langchain/chains\";\n * import { OpenAI } from \"langchain/llms/openai\";\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * // This is an LLMChain to write a synopsis given a title of a play.\n * const llm = new OpenAI({ temperature: 0 });\n * const template = `You are a playwright. Given the title of play, it is your job to write a synopsis for that title.\n *\n * Title: {title}\n * Playwright: This is a synopsis for the above play:`\n * const promptTemplate = new PromptTemplate({ template, inputVariables: [\"title\"] });\n * const synopsisChain = new LLMChain({ llm, prompt: promptTemplate });\n *\n *\n * // This is an LLMChain to write a review of a play given a synopsis.\n * const reviewLLM = new OpenAI({ temperature: 0 })\n * const reviewTemplate = `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\n *\n * Play Synopsis:\n * {synopsis}\n * Review from a New York Times play critic of the above play:`\n * const reviewPromptTemplate = new PromptTemplate({ template: reviewTemplate, inputVariables: [\"synopsis\"] });\n * const reviewChain = new LLMChain({ llm: reviewLLM, prompt: reviewPromptTemplate });\n *\n * const overallChain = new SimpleSequentialChain({chains: [synopsisChain, reviewChain], verbose:true})\n * const review = await overallChain.run(\"Tragedy at sunset on the beach\")\n * // the variable review contains resulting play review.\n * ```\n */\nexport class SimpleSequentialChain extends BaseChain {\n  static lc_name() {\n    return \"SimpleSequentialChain\";\n  }\n  get inputKeys() {\n    return [this.inputKey];\n  }\n  get outputKeys() {\n    return [this.outputKey];\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"chains\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"input\"\n    });\n    Object.defineProperty(this, \"outputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"output\"\n    });\n    Object.defineProperty(this, \"trimOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.chains = fields.chains;\n    this.trimOutputs = fields.trimOutputs ?? false;\n    this._validateChains();\n  }\n  /** @ignore */\n  _validateChains() {\n    for (const chain of this.chains) {\n      if (chain.inputKeys.filter(k => !chain.memory?.memoryKeys.includes(k) ?? true).length !== 1) {\n        throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${chain.inputKeys.length} for ${chain._chainType()}.`);\n      }\n      if (chain.outputKeys.length !== 1) {\n        throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${chain.outputKeys.length} for ${chain._chainType()}.`);\n      }\n    }\n  }\n  /** @ignore */\n  async _call(values, runManager) {\n    let input = values[this.inputKey];\n    let i = 0;\n    for (const chain of this.chains) {\n      i += 1;\n      input = (await chain.call({\n        [chain.inputKeys[0]]: input,\n        signal: values.signal\n      }, runManager?.getChild(`step_${i}`)))[chain.outputKeys[0]];\n      if (this.trimOutputs) {\n        input = input.trim();\n      }\n      await runManager?.handleText(input);\n    }\n    return {\n      [this.outputKey]: input\n    };\n  }\n  _chainType() {\n    return \"simple_sequential_chain\";\n  }\n  static async deserialize(data) {\n    const chains = [];\n    const serializedChains = data.chains;\n    for (const serializedChain of serializedChains) {\n      const deserializedChain = await BaseChain.deserialize(serializedChain);\n      chains.push(deserializedChain);\n    }\n    return new SimpleSequentialChain({\n      chains\n    });\n  }\n  serialize() {\n    const chains = [];\n    for (const chain of this.chains) {\n      chains.push(chain.serialize());\n    }\n    return {\n      _type: this._chainType(),\n      chains\n    };\n  }\n}"],
  "mappings": ";;;;;;;;AAMO,SAAS,aAAa,MAAM,MAAM;AACvC,QAAM,gBAAgB,oBAAI,IAAI;AAC9B,aAAW,QAAQ,MAAM;AACvB,QAAI,KAAK,IAAI,IAAI,GAAG;AAClB,oBAAc,IAAI,IAAI;AAAA,IACxB;AAAA,EACF;AACA,SAAO;AACT;AAIO,SAAS,MAAM,MAAM,MAAM;AAChC,QAAM,SAAS,IAAI,IAAI,IAAI;AAC3B,aAAW,QAAQ,MAAM;AACvB,WAAO,IAAI,IAAI;AAAA,EACjB;AACA,SAAO;AACT;AAIO,SAAS,WAAW,MAAM,MAAM;AACrC,QAAM,cAAc,IAAI,IAAI,IAAI;AAChC,aAAW,QAAQ,MAAM;AACvB,gBAAY,OAAO,IAAI;AAAA,EACzB;AACA,SAAO;AACT;;;AChCA,SAAS,UAAU,OAAO;AACxB,SAAO,MAAM,KAAK,KAAK,EAAE,IAAI,OAAK,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI;AACvD;AAmDO,IAAM,kBAAN,MAAM,yBAAwB,UAAU;AAAA,EAC7C,OAAO,UAAU;AACf,WAAO;AAAA,EACT;AAAA,EACA,IAAI,YAAY;AACd,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,aAAa;AACf,WAAO,KAAK;AAAA,EACd;AAAA,EACA,YAAY,QAAQ;AAClB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,UAAU;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,WAAO,eAAe,MAAM,kBAAkB;AAAA,MAC5C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,WAAO,eAAe,MAAM,mBAAmB;AAAA,MAC7C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,SAAK,SAAS,OAAO;AACrB,SAAK,iBAAiB,OAAO;AAC7B,SAAK,kBAAkB,OAAO,mBAAmB,CAAC;AAClD,QAAI,KAAK,gBAAgB,SAAS,KAAK,OAAO,WAAW;AACvD,YAAM,IAAI,MAAM,qIAAqI;AAAA,IACvJ;AACA,SAAK,YAAY,OAAO,aAAa;AACrC,SAAK,gBAAgB;AAAA,EACvB;AAAA;AAAA,EAEA,kBAAkB;AAChB,QAAI,KAAK,OAAO,WAAW,GAAG;AAC5B,YAAM,IAAI,MAAM,gDAAgD;AAAA,IAClE;AACA,UAAM,aAAa,KAAK,QAAQ,cAAc,CAAC;AAC/C,UAAM,eAAe,IAAI,IAAI,KAAK,SAAS;AAC3C,UAAM,gBAAgB,IAAI,IAAI,UAAU;AACxC,UAAM,mBAAmB,aAAa,cAAc,aAAa;AACjE,QAAI,iBAAiB,OAAO,GAAG;AAC7B,YAAM,IAAI,MAAM,uBAAuB,UAAU,gBAAgB,CAAC,oKAAoK;AAAA,IACxO;AACA,UAAM,gBAAgB,MAAM,cAAc,aAAa;AACvD,eAAW,SAAS,KAAK,QAAQ;AAC/B,UAAI,cAAc,WAAW,IAAI,IAAI,MAAM,SAAS,GAAG,aAAa;AACpE,UAAI,MAAM,QAAQ;AAChB,sBAAc,WAAW,aAAa,IAAI,IAAI,MAAM,OAAO,UAAU,CAAC;AAAA,MACxE;AACA,UAAI,YAAY,OAAO,GAAG;AACxB,cAAM,IAAI,MAAM,gCAAgC,MAAM,WAAW,CAAC,MAAM,UAAU,WAAW,CAAC,uCAAuC,UAAU,aAAa,CAAC,GAAG;AAAA,MAClK;AACA,YAAM,gBAAgB,IAAI,IAAI,MAAM,UAAU;AAC9C,YAAM,wBAAwB,aAAa,eAAe,aAAa;AACvE,UAAI,sBAAsB,OAAO,GAAG;AAClC,cAAM,IAAI,MAAM,6CAA6C,MAAM,WAAW,CAAC,sBAAsB,UAAU,qBAAqB,CAAC,0CAA0C;AAAA,MACjL;AACA,iBAAW,aAAa,eAAe;AACrC,sBAAc,IAAI,SAAS;AAAA,MAC7B;AAAA,IACF;AACA,QAAI,KAAK,gBAAgB,WAAW,GAAG;AACrC,UAAI,KAAK,WAAW;AAClB,cAAM,aAAa,WAAW,eAAe,YAAY;AACzD,aAAK,kBAAkB,MAAM,KAAK,UAAU;AAAA,MAC9C,OAAO;AACL,aAAK,kBAAkB,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE;AAAA,MAC7D;AAAA,IACF,OAAO;AACL,YAAM,cAAc,WAAW,IAAI,IAAI,KAAK,eAAe,GAAG,IAAI,IAAI,aAAa,CAAC;AACpF,UAAI,YAAY,OAAO,GAAG;AACxB,cAAM,IAAI,MAAM,oGAAoG,UAAU,WAAW,CAAC,GAAG;AAAA,MAC/I;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAEM,MAAM,QAAQ,YAAY;AAAA;AAC9B,UAAI,QAAQ,CAAC;AACb,YAAM,iBAAiB;AACvB,UAAI,IAAI;AACR,iBAAW,SAAS,KAAK,QAAQ;AAC/B,aAAK;AACL,gBAAQ,MAAM,MAAM,KAAK,gBAAgB,YAAY,SAAS,QAAQ,CAAC,EAAE,CAAC;AAC1E,mBAAW,OAAO,OAAO,KAAK,KAAK,GAAG;AACpC,yBAAe,GAAG,IAAI,MAAM,GAAG;AAAA,QACjC;AAAA,MACF;AACA,YAAM,SAAS,CAAC;AAChB,iBAAW,OAAO,KAAK,iBAAiB;AACtC,eAAO,GAAG,IAAI,eAAe,GAAG;AAAA,MAClC;AACA,aAAO;AAAA,IACT;AAAA;AAAA,EACA,aAAa;AACX,WAAO;AAAA,EACT;AAAA,EACA,OAAa,YAAY,MAAM;AAAA;AAC7B,YAAM,SAAS,CAAC;AAChB,YAAM,iBAAiB,KAAK;AAC5B,YAAM,kBAAkB,KAAK;AAC7B,YAAM,mBAAmB,KAAK;AAC9B,iBAAW,mBAAmB,kBAAkB;AAC9C,cAAM,oBAAoB,MAAM,UAAU,YAAY,eAAe;AACrE,eAAO,KAAK,iBAAiB;AAAA,MAC/B;AACA,aAAO,IAAI,iBAAgB;AAAA,QACzB;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA,EACA,YAAY;AACV,UAAM,SAAS,CAAC;AAChB,eAAW,SAAS,KAAK,QAAQ;AAC/B,aAAO,KAAK,MAAM,UAAU,CAAC;AAAA,IAC/B;AACA,WAAO;AAAA,MACL,OAAO,KAAK,WAAW;AAAA,MACvB,iBAAiB,KAAK;AAAA,MACtB,kBAAkB,KAAK;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AACF;AAsCO,IAAM,wBAAN,MAAM,+BAA8B,UAAU;AAAA,EACnD,OAAO,UAAU;AACf,WAAO;AAAA,EACT;AAAA,EACA,IAAI,YAAY;AACd,WAAO,CAAC,KAAK,QAAQ;AAAA,EACvB;AAAA,EACA,IAAI,aAAa;AACf,WAAO,CAAC,KAAK,SAAS;AAAA,EACxB;AAAA,EACA,YAAY,QAAQ;AAClB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,UAAU;AAAA,MACpC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,WAAO,eAAe,MAAM,YAAY;AAAA,MACtC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACvC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,WAAO,eAAe,MAAM,eAAe;AAAA,MACzC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACT,CAAC;AACD,SAAK,SAAS,OAAO;AACrB,SAAK,cAAc,OAAO,eAAe;AACzC,SAAK,gBAAgB;AAAA,EACvB;AAAA;AAAA,EAEA,kBAAkB;AAChB,eAAW,SAAS,KAAK,QAAQ;AAC/B,UAAI,MAAM,UAAU,OAAO,OAAK,CAAC,MAAM,QAAQ,WAAW,SAAS,CAAC,CAAS,EAAE,WAAW,GAAG;AAC3F,cAAM,IAAI,MAAM,uEAAuE,MAAM,UAAU,MAAM,QAAQ,MAAM,WAAW,CAAC,GAAG;AAAA,MAC5I;AACA,UAAI,MAAM,WAAW,WAAW,GAAG;AACjC,cAAM,IAAI,MAAM,wEAAwE,MAAM,WAAW,MAAM,QAAQ,MAAM,WAAW,CAAC,GAAG;AAAA,MAC9I;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAEM,MAAM,QAAQ,YAAY;AAAA;AAC9B,UAAI,QAAQ,OAAO,KAAK,QAAQ;AAChC,UAAI,IAAI;AACR,iBAAW,SAAS,KAAK,QAAQ;AAC/B,aAAK;AACL,iBAAS,MAAM,MAAM,KAAK;AAAA,UACxB,CAAC,MAAM,UAAU,CAAC,CAAC,GAAG;AAAA,UACtB,QAAQ,OAAO;AAAA,QACjB,GAAG,YAAY,SAAS,QAAQ,CAAC,EAAE,CAAC,GAAG,MAAM,WAAW,CAAC,CAAC;AAC1D,YAAI,KAAK,aAAa;AACpB,kBAAQ,MAAM,KAAK;AAAA,QACrB;AACA,cAAM,YAAY,WAAW,KAAK;AAAA,MACpC;AACA,aAAO;AAAA,QACL,CAAC,KAAK,SAAS,GAAG;AAAA,MACpB;AAAA,IACF;AAAA;AAAA,EACA,aAAa;AACX,WAAO;AAAA,EACT;AAAA,EACA,OAAa,YAAY,MAAM;AAAA;AAC7B,YAAM,SAAS,CAAC;AAChB,YAAM,mBAAmB,KAAK;AAC9B,iBAAW,mBAAmB,kBAAkB;AAC9C,cAAM,oBAAoB,MAAM,UAAU,YAAY,eAAe;AACrE,eAAO,KAAK,iBAAiB;AAAA,MAC/B;AACA,aAAO,IAAI,uBAAsB;AAAA,QAC/B;AAAA,MACF,CAAC;AAAA,IACH;AAAA;AAAA,EACA,YAAY;AACV,UAAM,SAAS,CAAC;AAChB,eAAW,SAAS,KAAK,QAAQ;AAC/B,aAAO,KAAK,MAAM,UAAU,CAAC;AAAA,IAC/B;AACA,WAAO;AAAA,MACL,OAAO,KAAK,WAAW;AAAA,MACvB;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
