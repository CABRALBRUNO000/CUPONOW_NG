{
  "version": 3,
  "sources": ["../../../../../../node_modules/@langchain/core/dist/output_parsers/base.js", "../../../../../../node_modules/@langchain/core/dist/output_parsers/structured.js", "../../../../../../node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/deep-compare-strict.js", "../../../../../../node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.js", "../../../../../../node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/format.js", "../../../../../../node_modules/@langchain/core/dist/output_parsers/transform.js", "../../../../../../node_modules/@langchain/core/dist/output_parsers/json.js", "../../../../../../node_modules/@langchain/core/dist/utils/sax-js/sax.js"],
  "sourcesContent": ["import { Runnable } from \"../runnables/index.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport class BaseLLMOutputParser extends Runnable {\n  /**\n   * Parses the result of an LLM call with a given prompt. By default, it\n   * simply calls `parseResult`.\n   * @param generations The generations from an LLM call.\n   * @param _prompt The prompt used in the LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parseResultWithPrompt(generations, _prompt, callbacks) {\n    return this.parseResult(generations, callbacks);\n  }\n  _baseMessageToString(message) {\n    return typeof message.content === \"string\" ? message.content : this._baseMessageContentToString(message.content);\n  }\n  _baseMessageContentToString(content) {\n    return JSON.stringify(content);\n  }\n  /**\n   * Calls the parser with a given input and optional configuration options.\n   * If the input is a string, it creates a generation with the input as\n   * text and calls `parseResult`. If the input is a `BaseMessage`, it\n   * creates a generation with the input as a message and the content of the\n   * input as text, and then calls `parseResult`.\n   * @param input The input to the parser, which can be a string or a `BaseMessage`.\n   * @param options Optional configuration options.\n   * @returns A promise of the parsed output.\n   */\n  async invoke(input, options) {\n    if (typeof input === \"string\") {\n      return this._callWithConfig(async (input, options) => this.parseResult([{\n        text: input\n      }], options?.callbacks), input, {\n        ...options,\n        runType: \"parser\"\n      });\n    } else {\n      return this._callWithConfig(async (input, options) => this.parseResult([{\n        message: input,\n        text: this._baseMessageToString(input)\n      }], options?.callbacks), input, {\n        ...options,\n        runType: \"parser\"\n      });\n    }\n  }\n}\n/**\n * Class to parse the output of an LLM call.\n */\nexport class BaseOutputParser extends BaseLLMOutputParser {\n  parseResult(generations, callbacks) {\n    return this.parse(generations[0].text, callbacks);\n  }\n  async parseWithPrompt(text, _prompt, callbacks) {\n    return this.parse(text, callbacks);\n  }\n  /**\n   * Return the string type key uniquely identifying this class of parser\n   */\n  _type() {\n    throw new Error(\"_type not implemented\");\n  }\n}\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nexport class OutputParserException extends Error {\n  constructor(message, llmOutput, observation, sendToLLM = false) {\n    super(message);\n    Object.defineProperty(this, \"llmOutput\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"observation\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sendToLLM\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.llmOutput = llmOutput;\n    this.observation = observation;\n    this.sendToLLM = sendToLLM;\n    if (sendToLLM) {\n      if (observation === undefined || llmOutput === undefined) {\n        throw new Error(\"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\");\n      }\n    }\n    addLangChainErrorFields(this, \"OUTPUT_PARSING_FAILURE\");\n  }\n}", "import { z } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { BaseOutputParser, OutputParserException } from \"./base.js\";\nexport class StructuredOutputParser extends BaseOutputParser {\n  static lc_name() {\n    return \"StructuredOutputParser\";\n  }\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n  constructor(schema) {\n    super(schema);\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: schema\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"structured\"]\n    });\n  }\n  /**\n   * Creates a new StructuredOutputParser from a Zod schema.\n   * @param schema The Zod schema which the output should match\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromZodSchema(schema) {\n    return new this(schema);\n  }\n  /**\n   * Creates a new StructuredOutputParser from a set of names and\n   * descriptions.\n   * @param schemas An object where each key is a name and each value is a description\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromNamesAndDescriptions(schemas) {\n    const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));\n    return new this(zodSchema);\n  }\n  /**\n   * Returns a markdown code snippet with a JSON object formatted according\n   * to the schema.\n   * @param options Optional. The options for formatting the instructions\n   * @returns A markdown code snippet with a JSON object formatted according to the schema.\n   */\n  getFormatInstructions() {\n    return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(zodToJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n  }\n  /**\n   * Parses the given text according to the schema.\n   * @param text The text to parse\n   * @returns The parsed output.\n   */\n  async parse(text) {\n    try {\n      const json = text.includes(\"```\") ? text.trim().split(/```(?:json)?/)[1] : text.trim();\n      const escapedJson = json.replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n        const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n        return `\"${escapedInsideQuotes}\"`;\n      }).replace(/\\n/g, \"\");\n      return await this.schema.parseAsync(JSON.parse(escapedJson));\n    } catch (e) {\n      throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n    }\n  }\n}\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser extends StructuredOutputParser {\n  static lc_name() {\n    return \"JsonMarkdownStructuredOutputParser\";\n  }\n  getFormatInstructions(options) {\n    const interpolationDepth = options?.interpolationDepth ?? 1;\n    if (interpolationDepth < 1) {\n      throw new Error(\"f string interpolation depth must be at least 1\");\n    }\n    return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(zodToJsonSchema(this.schema)).replaceAll(\"{\", \"{\".repeat(interpolationDepth)).replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n  }\n  _schemaToInstruction(schemaInput, indent = 2) {\n    const schema = schemaInput;\n    if (\"type\" in schema) {\n      let nullable = false;\n      let type;\n      if (Array.isArray(schema.type)) {\n        const nullIdx = schema.type.findIndex(type => type === \"null\");\n        if (nullIdx !== -1) {\n          nullable = true;\n          schema.type.splice(nullIdx, 1);\n        }\n        type = schema.type.join(\" | \");\n      } else {\n        type = schema.type;\n      }\n      if (schema.type === \"object\" && schema.properties) {\n        const description = schema.description ? ` // ${schema.description}` : \"\";\n        const properties = Object.entries(schema.properties).map(([key, value]) => {\n          const isOptional = schema.required?.includes(key) ? \"\" : \" (optional)\";\n          return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;\n        }).join(\"\\n\");\n        return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n      }\n      if (schema.type === \"array\" && schema.items) {\n        const description = schema.description ? ` // ${schema.description}` : \"\";\n        return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}\\n${\" \".repeat(indent - 2)}] ${description}`;\n      }\n      const isNullable = nullable ? \" (nullable)\" : \"\";\n      const description = schema.description ? ` // ${schema.description}` : \"\";\n      return `${type}${description}${isNullable}`;\n    }\n    if (\"anyOf\" in schema) {\n      return schema.anyOf.map(s => this._schemaToInstruction(s, indent)).join(`\\n${\" \".repeat(indent - 2)}`);\n    }\n    throw new Error(\"unsupported schema type\");\n  }\n  static fromZodSchema(schema) {\n    return new this(schema);\n  }\n  static fromNamesAndDescriptions(schemas) {\n    const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));\n    return new this(zodSchema);\n  }\n}\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport class AsymmetricStructuredOutputParser extends BaseOutputParser {\n  constructor({\n    inputSchema\n  }) {\n    super(...arguments);\n    Object.defineProperty(this, \"structuredInputParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);\n  }\n  async parse(text) {\n    let parsedInput;\n    try {\n      parsedInput = await this.structuredInputParser.parse(text);\n    } catch (e) {\n      throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n    }\n    return this.outputProcessor(parsedInput);\n  }\n  getFormatInstructions() {\n    return this.structuredInputParser.getFormatInstructions();\n  }\n}", "export function deepCompareStrict(a, b) {\n  const typeofa = typeof a;\n  if (typeofa !== typeof b) {\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n    const length = a.length;\n    if (length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      if (!deepCompareStrict(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (typeofa === \"object\") {\n    if (!a || !b) {\n      return a === b;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    const length = aKeys.length;\n    if (length !== bKeys.length) {\n      return false;\n    }\n    for (const k of aKeys) {\n      if (!deepCompareStrict(a[k], b[k])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a === b;\n}", "import { encodePointer } from \"./pointer.js\";\nexport const schemaKeyword = {\n  additionalItems: true,\n  unevaluatedItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  unevaluatedProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\nexport const schemaArrayKeyword = {\n  prefixItems: true,\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\nexport const schemaMapKeyword = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependentSchemas: true\n};\nexport const ignoredKeyword = {\n  id: true,\n  $id: true,\n  $ref: true,\n  $schema: true,\n  $anchor: true,\n  $vocabulary: true,\n  $comment: true,\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  type: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n/**\n * Default base URI for schemas without an $id.\n * https://json-schema.org/draft/2019-09/json-schema-core.html#initial-base\n * https://tools.ietf.org/html/rfc3986#section-5.1\n */\nexport let initialBaseURI =\n// @ts-ignore\ntypeof self !== \"undefined\" && self.location && self.location.origin !== \"null\" ?\n//@ts-ignore\n/* #__PURE__ */\nnew URL(self.location.origin + self.location.pathname + location.search) : /* #__PURE__ */new URL(\"https://github.com/cfworker\");\nexport function dereference(schema, lookup = Object.create(null), baseURI = initialBaseURI, basePointer = \"\") {\n  if (schema && typeof schema === \"object\" && !Array.isArray(schema)) {\n    const id = schema.$id || schema.id;\n    if (id) {\n      const url = new URL(id, baseURI.href);\n      if (url.hash.length > 1) {\n        lookup[url.href] = schema;\n      } else {\n        url.hash = \"\"; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n        if (basePointer === \"\") {\n          baseURI = url;\n        } else {\n          dereference(schema, lookup, baseURI);\n        }\n      }\n    }\n  } else if (schema !== true && schema !== false) {\n    return lookup;\n  }\n  // compute the schema's URI and add it to the mapping.\n  const schemaURI = baseURI.href + (basePointer ? \"#\" + basePointer : \"\");\n  if (lookup[schemaURI] !== undefined) {\n    throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n  }\n  lookup[schemaURI] = schema;\n  // exit early if this is a boolean schema.\n  if (schema === true || schema === false) {\n    return lookup;\n  }\n  // set the schema's absolute URI.\n  if (schema.__absolute_uri__ === undefined) {\n    Object.defineProperty(schema, \"__absolute_uri__\", {\n      enumerable: false,\n      value: schemaURI\n    });\n  }\n  // if a $ref is found, resolve it's absolute URI.\n  if (schema.$ref && schema.__absolute_ref__ === undefined) {\n    const url = new URL(schema.$ref, baseURI.href);\n    url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n    Object.defineProperty(schema, \"__absolute_ref__\", {\n      enumerable: false,\n      value: url.href\n    });\n  }\n  // if a $recursiveRef is found, resolve it's absolute URI.\n  if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n    const url = new URL(schema.$recursiveRef, baseURI.href);\n    url.hash = url.hash; // normalize hash https://url.spec.whatwg.org/#dom-url-hash\n    Object.defineProperty(schema, \"__absolute_recursive_ref__\", {\n      enumerable: false,\n      value: url.href\n    });\n  }\n  // if an $anchor is found, compute it's URI and add it to the mapping.\n  if (schema.$anchor) {\n    const url = new URL(\"#\" + schema.$anchor, baseURI.href);\n    lookup[url.href] = schema;\n  }\n  // process subschemas.\n  for (let key in schema) {\n    if (ignoredKeyword[key]) {\n      continue;\n    }\n    const keyBase = `${basePointer}/${encodePointer(key)}`;\n    const subSchema = schema[key];\n    if (Array.isArray(subSchema)) {\n      if (schemaArrayKeyword[key]) {\n        const length = subSchema.length;\n        for (let i = 0; i < length; i++) {\n          dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n        }\n      }\n    } else if (schemaMapKeyword[key]) {\n      for (let subKey in subSchema) {\n        dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);\n      }\n    } else {\n      dereference(subSchema, lookup, baseURI, keyBase);\n    }\n  }\n  return lookup;\n}\n// schema identification examples\n// https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.appendix.A\n// $ref delegation\n// https://github.com/json-schema-org/json-schema-spec/issues/514\n// output format\n// https://json-schema.org/draft/2019-09/json-schema-core.html#output\n// JSON pointer\n// https://tools.ietf.org/html/rfc6901\n// JSON relative pointer\n// https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01", "// based on https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\n// const URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nconst URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// For the source: https://gist.github.com/dperini/729294\n// For test cases: https://mathiasbynens.be/demo/url-regex\nconst URL_ = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nconst UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nconst JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nconst RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n// date: http://tools.ietf.org/html/rfc3339#section-5.6\nconst FASTDATE = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/;\n// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\nconst FASTTIME = /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst FASTDATETIME = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i;\n// uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n// const FASTURI = /^(?:[a-z][a-z0-9+-.]*:)(?:\\/?\\/)?[^\\s]*$/i;\nconst FASTURIREFERENCE = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i;\n// https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\nconst EMAIL = input => {\n  if (input[0] === '\"') return false;\n  const [name, host, ...rest] = input.split(\"@\");\n  if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) return false;\n  if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\")) return false;\n  if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) return false;\n  return host.split(\".\").every(part => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));\n};\n// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\nconst IPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\n// optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\nconst IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\n// https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\nconst DURATION = input => input.length > 1 && input.length < 80 && (/^P\\d+([.,]\\d+)?W$/.test(input) || /^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(input) && /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(input));\nfunction bind(r) {\n  return r.test.bind(r);\n}\nexport const fullFormat = {\n  date,\n  time: /* #__PURE__ */time.bind(undefined, false),\n  \"date-time\": date_time,\n  duration: DURATION,\n  uri,\n  \"uri-reference\": /* #__PURE__ */bind(URIREF),\n  \"uri-template\": /* #__PURE__ */bind(URITEMPLATE),\n  url: /* #__PURE__ */bind(URL_),\n  email: EMAIL,\n  hostname: /* #__PURE__ */bind(HOSTNAME),\n  ipv4: /* #__PURE__ */bind(IPV4),\n  ipv6: /* #__PURE__ */bind(IPV6),\n  regex: regex,\n  uuid: /* #__PURE__ */bind(UUID),\n  \"json-pointer\": /* #__PURE__ */bind(JSON_POINTER),\n  \"json-pointer-uri-fragment\": /* #__PURE__ */bind(JSON_POINTER_URI_FRAGMENT),\n  \"relative-json-pointer\": /* #__PURE__ */bind(RELATIVE_JSON_POINTER)\n};\nexport const fastFormat = {\n  ...fullFormat,\n  date: /* #__PURE__ */bind(FASTDATE),\n  time: /* #__PURE__ */bind(FASTTIME),\n  \"date-time\": /* #__PURE__ */bind(FASTDATETIME),\n  \"uri-reference\": /* #__PURE__ */bind(FASTURIREFERENCE)\n};\nfunction isLeapYear(year) {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction date(str) {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  const matches = str.match(DATE);\n  if (!matches) return false;\n  const year = +matches[1];\n  const month = +matches[2];\n  const day = +matches[3];\n  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);\n}\nfunction time(full, str) {\n  const matches = str.match(TIME);\n  if (!matches) return false;\n  const hour = +matches[1];\n  const minute = +matches[2];\n  const second = +matches[3];\n  const timeZone = !!matches[5];\n  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  const dateTime = str.split(DATE_TIME_SEPARATOR);\n  return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI_PATTERN = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n  if (Z_ANCHOR.test(str)) return false;\n  try {\n    new RegExp(str);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}", "import { BaseOutputParser } from \"./base.js\";\nimport { isBaseMessage, isBaseMessageChunk } from \"../messages/base.js\";\nimport { convertToChunk } from \"../messages/utils.js\";\nimport { GenerationChunk, ChatGenerationChunk } from \"../outputs.js\";\nimport { deepCompareStrict } from \"../utils/@cfworker/json-schema/index.js\";\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport class BaseTransformOutputParser extends BaseOutputParser {\n  async *_transform(inputGenerator) {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{\n          text: chunk\n        }]);\n      } else {\n        yield this.parseResult([{\n          message: chunk,\n          text: this._baseMessageToString(chunk)\n        }]);\n      }\n    }\n  }\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(inputGenerator, options) {\n    yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {\n      ...options,\n      runType: \"parser\"\n    });\n  }\n}\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport class BaseCumulativeTransformOutputParser extends BaseTransformOutputParser {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"diff\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    this.diff = fields?.diff ?? this.diff;\n  }\n  async *_transform(inputGenerator) {\n    let prevParsed;\n    let accGen;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: convertToChunk(chunk),\n          text: chunk.content\n        });\n      } else {\n        chunkGen = new GenerationChunk({\n          text: chunk\n        });\n      }\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n      const parsed = await this.parsePartialResult([accGen]);\n      if (parsed !== undefined && parsed !== null && !deepCompareStrict(parsed, prevParsed)) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n  getFormatInstructions() {\n    return \"\";\n  }\n}", "import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { compare } from \"../utils/json_patch.js\";\nimport { parseJsonMarkdown, parsePartialJson } from \"../utils/json.js\";\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nexport class JsonOutputParser extends BaseCumulativeTransformOutputParser {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"output_parsers\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  static lc_name() {\n    return \"JsonOutputParser\";\n  }\n  _diff(prev, next) {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{\n        op: \"replace\",\n        path: \"\",\n        value: next\n      }];\n    }\n    return compare(prev, next);\n  }\n  // This should actually return Partial<T>, but there's no way\n  // to specify emitted chunks as instances separate from the main output type.\n  async parsePartialResult(generations) {\n    return parseJsonMarkdown(generations[0].text);\n  }\n  async parse(text) {\n    return parseJsonMarkdown(text, JSON.parse);\n  }\n  getFormatInstructions() {\n    return \"\";\n  }\n}\nexport { parsePartialJson, parseJsonMarkdown };", "// @ts-nocheck\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\nconst initializeSax = function () {\n  const sax = {};\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream;\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n  const buffers = [\"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\", \"procInstName\", \"procInstBody\", \"entity\", \"attribName\", \"attribValue\", \"cdata\", \"script\"];\n  sax.EVENTS = [\"text\", \"processinginstruction\", \"sgmldeclaration\", \"doctype\", \"comment\", \"opentagstart\", \"attribute\", \"opentag\", \"closetag\", \"opencdata\", \"cdata\", \"closecdata\", \"error\", \"end\", \"ready\", \"script\", \"opennamespace\", \"closenamespace\"];\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt);\n    }\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.strictEntities = parser.opt.strictEntities;\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);\n    parser.attribList = [];\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS);\n    }\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false;\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n    emit(parser, \"onready\");\n  }\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F() {}\n      F.prototype = o;\n      var newf = new F();\n      return newf;\n    };\n  }\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n  }\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n  function flushBuffers(parser) {\n    closeText(parser);\n    if (parser.cdata !== \"\") {\n      emitNode(parser, \"oncdata\", parser.cdata);\n      parser.cdata = \"\";\n    }\n    if (parser.script !== \"\") {\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n  }\n  SAXParser.prototype = {\n    end: function () {\n      end(this);\n    },\n    write: write,\n    resume: function () {\n      this.error = null;\n      return this;\n    },\n    close: function () {\n      return this.write(null);\n    },\n    flush: function () {\n      flushBuffers(this);\n    }\n  };\n  var Stream = ReadableStream;\n  if (!Stream) Stream = function () {};\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt);\n    }\n    Stream.apply(this);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null;\n    };\n    this._decoder = null;\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function () {\n          return me._parser[\"on\" + ev];\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            me._parser[\"on\" + ev] = h;\n            return h;\n          }\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false\n      });\n    });\n  }\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  });\n  SAXStream.prototype.write = function (data) {\n    this._parser.write(data.toString());\n    this.emit(\"data\", data);\n    return true;\n  };\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk);\n    }\n    this._parser.end();\n    return true;\n  };\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = \"[CDATA[\";\n  var DOCTYPE = \"DOCTYPE\";\n  var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n  var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n  var rootNS = {\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE\n  };\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n  function isWhitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n  }\n  function isQuote(c) {\n    return c === '\"' || c === \"'\";\n  }\n  function isAttribEnd(c) {\n    return c === \">\" || isWhitespace(c);\n  }\n  function isMatch(regex, c) {\n    return regex.test(c);\n  }\n  function notMatch(regex, c) {\n    return !isMatch(regex, c);\n  }\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++,\n    BEGIN_WHITESPACE: S++,\n    TEXT: S++,\n    TEXT_ENTITY: S++,\n    OPEN_WAKA: S++,\n    SGML_DECL: S++,\n    SGML_DECL_QUOTED: S++,\n    DOCTYPE: S++,\n    DOCTYPE_QUOTED: S++,\n    DOCTYPE_DTD: S++,\n    DOCTYPE_DTD_QUOTED: S++,\n    COMMENT_STARTING: S++,\n    COMMENT: S++,\n    COMMENT_ENDING: S++,\n    COMMENT_ENDED: S++,\n    CDATA: S++,\n    CDATA_ENDING: S++,\n    CDATA_ENDING_2: S++,\n    PROC_INST: S++,\n    PROC_INST_BODY: S++,\n    PROC_INST_ENDING: S++,\n    OPEN_TAG: S++,\n    OPEN_TAG_SLASH: S++,\n    ATTRIB: S++,\n    ATTRIB_NAME: S++,\n    ATTRIB_NAME_SAW_WHITE: S++,\n    ATTRIB_VALUE: S++,\n    ATTRIB_VALUE_QUOTED: S++,\n    ATTRIB_VALUE_CLOSED: S++,\n    ATTRIB_VALUE_UNQUOTED: S++,\n    ATTRIB_VALUE_ENTITY_Q: S++,\n    ATTRIB_VALUE_ENTITY_U: S++,\n    CLOSE_TAG: S++,\n    CLOSE_TAG_SAW_WHITE: S++,\n    SCRIPT: S++,\n    SCRIPT_ENDING: S++ // <script> ... <\n  };\n  sax.XML_ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\"\n  };\n  sax.ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n    AElig: 198,\n    Aacute: 193,\n    Acirc: 194,\n    Agrave: 192,\n    Aring: 197,\n    Atilde: 195,\n    Auml: 196,\n    Ccedil: 199,\n    ETH: 208,\n    Eacute: 201,\n    Ecirc: 202,\n    Egrave: 200,\n    Euml: 203,\n    Iacute: 205,\n    Icirc: 206,\n    Igrave: 204,\n    Iuml: 207,\n    Ntilde: 209,\n    Oacute: 211,\n    Ocirc: 212,\n    Ograve: 210,\n    Oslash: 216,\n    Otilde: 213,\n    Ouml: 214,\n    THORN: 222,\n    Uacute: 218,\n    Ucirc: 219,\n    Ugrave: 217,\n    Uuml: 220,\n    Yacute: 221,\n    aacute: 225,\n    acirc: 226,\n    aelig: 230,\n    agrave: 224,\n    aring: 229,\n    atilde: 227,\n    auml: 228,\n    ccedil: 231,\n    eacute: 233,\n    ecirc: 234,\n    egrave: 232,\n    eth: 240,\n    euml: 235,\n    iacute: 237,\n    icirc: 238,\n    igrave: 236,\n    iuml: 239,\n    ntilde: 241,\n    oacute: 243,\n    ocirc: 244,\n    ograve: 242,\n    oslash: 248,\n    otilde: 245,\n    ouml: 246,\n    szlig: 223,\n    thorn: 254,\n    uacute: 250,\n    ucirc: 251,\n    ugrave: 249,\n    uuml: 252,\n    yacute: 253,\n    yuml: 255,\n    copy: 169,\n    reg: 174,\n    nbsp: 160,\n    iexcl: 161,\n    cent: 162,\n    pound: 163,\n    curren: 164,\n    yen: 165,\n    brvbar: 166,\n    sect: 167,\n    uml: 168,\n    ordf: 170,\n    laquo: 171,\n    not: 172,\n    shy: 173,\n    macr: 175,\n    deg: 176,\n    plusmn: 177,\n    sup1: 185,\n    sup2: 178,\n    sup3: 179,\n    acute: 180,\n    micro: 181,\n    para: 182,\n    middot: 183,\n    cedil: 184,\n    ordm: 186,\n    raquo: 187,\n    frac14: 188,\n    frac12: 189,\n    frac34: 190,\n    iquest: 191,\n    times: 215,\n    divide: 247,\n    OElig: 338,\n    oelig: 339,\n    Scaron: 352,\n    scaron: 353,\n    Yuml: 376,\n    fnof: 402,\n    circ: 710,\n    tilde: 732,\n    Alpha: 913,\n    Beta: 914,\n    Gamma: 915,\n    Delta: 916,\n    Epsilon: 917,\n    Zeta: 918,\n    Eta: 919,\n    Theta: 920,\n    Iota: 921,\n    Kappa: 922,\n    Lambda: 923,\n    Mu: 924,\n    Nu: 925,\n    Xi: 926,\n    Omicron: 927,\n    Pi: 928,\n    Rho: 929,\n    Sigma: 931,\n    Tau: 932,\n    Upsilon: 933,\n    Phi: 934,\n    Chi: 935,\n    Psi: 936,\n    Omega: 937,\n    alpha: 945,\n    beta: 946,\n    gamma: 947,\n    delta: 948,\n    epsilon: 949,\n    zeta: 950,\n    eta: 951,\n    theta: 952,\n    iota: 953,\n    kappa: 954,\n    lambda: 955,\n    mu: 956,\n    nu: 957,\n    xi: 958,\n    omicron: 959,\n    pi: 960,\n    rho: 961,\n    sigmaf: 962,\n    sigma: 963,\n    tau: 964,\n    upsilon: 965,\n    phi: 966,\n    chi: 967,\n    psi: 968,\n    omega: 969,\n    thetasym: 977,\n    upsih: 978,\n    piv: 982,\n    ensp: 8194,\n    emsp: 8195,\n    thinsp: 8201,\n    zwnj: 8204,\n    zwj: 8205,\n    lrm: 8206,\n    rlm: 8207,\n    ndash: 8211,\n    mdash: 8212,\n    lsquo: 8216,\n    rsquo: 8217,\n    sbquo: 8218,\n    ldquo: 8220,\n    rdquo: 8221,\n    bdquo: 8222,\n    dagger: 8224,\n    Dagger: 8225,\n    bull: 8226,\n    hellip: 8230,\n    permil: 8240,\n    prime: 8242,\n    Prime: 8243,\n    lsaquo: 8249,\n    rsaquo: 8250,\n    oline: 8254,\n    frasl: 8260,\n    euro: 8364,\n    image: 8465,\n    weierp: 8472,\n    real: 8476,\n    trade: 8482,\n    alefsym: 8501,\n    larr: 8592,\n    uarr: 8593,\n    rarr: 8594,\n    darr: 8595,\n    harr: 8596,\n    crarr: 8629,\n    lArr: 8656,\n    uArr: 8657,\n    rArr: 8658,\n    dArr: 8659,\n    hArr: 8660,\n    forall: 8704,\n    part: 8706,\n    exist: 8707,\n    empty: 8709,\n    nabla: 8711,\n    isin: 8712,\n    notin: 8713,\n    ni: 8715,\n    prod: 8719,\n    sum: 8721,\n    minus: 8722,\n    lowast: 8727,\n    radic: 8730,\n    prop: 8733,\n    infin: 8734,\n    ang: 8736,\n    and: 8743,\n    or: 8744,\n    cap: 8745,\n    cup: 8746,\n    int: 8747,\n    there4: 8756,\n    sim: 8764,\n    cong: 8773,\n    asymp: 8776,\n    ne: 8800,\n    equiv: 8801,\n    le: 8804,\n    ge: 8805,\n    sub: 8834,\n    sup: 8835,\n    nsub: 8836,\n    sube: 8838,\n    supe: 8839,\n    oplus: 8853,\n    otimes: 8855,\n    perp: 8869,\n    sdot: 8901,\n    lceil: 8968,\n    rceil: 8969,\n    lfloor: 8970,\n    rfloor: 8971,\n    lang: 9001,\n    rang: 9002,\n    loz: 9674,\n    spades: 9824,\n    clubs: 9827,\n    hearts: 9829,\n    diams: 9830\n  };\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key];\n    var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n    sax.ENTITIES[key] = s;\n  });\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s;\n  }\n  // shorthand\n  S = sax.STATE;\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n  function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n      er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n  function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, \"Unclosed root tag\");\n    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n      error(parser, \"Unexpected end\");\n    }\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n  function strictFail(parser, message) {\n    if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n      throw new Error(\"bad call to strictFail\");\n    }\n    if (parser.strict) {\n      error(parser, message);\n    }\n  }\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = parser.tag = {\n      name: parser.tagName,\n      attributes: {}\n    };\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns;\n    }\n    parser.attribList.length = 0;\n    emitNode(parser, \"onopentagstart\", tag);\n  }\n  function qname(name, attribute) {\n    var i = name.indexOf(\":\");\n    var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n    var prefix = qualName[0];\n    var local = qualName[1];\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n    return {\n      prefix: prefix,\n      local: local\n    };\n  }\n  function attrib(parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]();\n    }\n    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = \"\";\n      return;\n    }\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true);\n      var prefix = qn.prefix;\n      var local = qn.local;\n      if (prefix === \"xmlns\") {\n        // namespace binding attribute. push the binding into scope\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser, \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser, \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else {\n          var tag = parser.tag;\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n          tag.ns[local] = parser.attribValue;\n        }\n      }\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue\n      });\n    }\n    parser.attribName = parser.attribValue = \"\";\n  }\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag;\n      // add namespace info to tag\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || \"\";\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n        tag.uri = qn.prefix;\n      }\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p]\n          });\n        });\n      }\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0];\n        var value = nv[1];\n        var qualName = qname(name, true);\n        var prefix = qualName.prefix;\n        var local = qualName.local;\n        var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        };\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== \"xmlns\" && !uri) {\n          strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n          a.uri = prefix;\n        }\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n      parser.attribList.length = 0;\n    }\n    parser.tag.isSelfClosing = !!selfClosing;\n    // process the tag\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    }\n    if (parser.script) {\n      if (parser.tagName !== \"script\") {\n        parser.script += \"</\" + parser.tagName + \">\";\n        parser.tagName = \"\";\n        parser.state = S.SCRIPT;\n        return;\n      }\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]();\n    }\n    var closeTo = tagName;\n    while (t--) {\n      var close = parser.tags[t];\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, \"Unexpected close tag\");\n      } else {\n        break;\n      }\n    }\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop();\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n      var x = {};\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i];\n      }\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", {\n            prefix: p,\n            uri: n\n          });\n        });\n      }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n  function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = \"\";\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity];\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC];\n    }\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n    return String.fromCodePoint(num);\n  }\n  function beginWhiteSpace(parser, c) {\n    if (c === \"<\") {\n      parser.state = S.OPEN_WAKA;\n      parser.startTagPosition = parser.position;\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, \"Non-whitespace before first tag.\");\n      parser.textNode = c;\n      parser.state = S.TEXT;\n    }\n  }\n  function charAt(chunk, i) {\n    var result = \"\";\n    if (i < chunk.length) {\n      result = chunk.charAt(i);\n    }\n    return result;\n  }\n  function write(chunk) {\n    var parser = this;\n    if (this.error) {\n      throw this.error;\n    }\n    if (parser.closed) {\n      return error(parser, \"Cannot write after close. Assign an onready handler.\");\n    }\n    if (chunk === null) {\n      return end(parser);\n    }\n    if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    }\n    var i = 0;\n    var c = \"\";\n    while (true) {\n      c = charAt(chunk, i++);\n      parser.c = c;\n      if (!c) {\n        break;\n      }\n      if (parser.trackPosition) {\n        parser.position++;\n        if (c === \"\\n\") {\n          parser.line++;\n          parser.column = 0;\n        } else {\n          parser.column++;\n        }\n      }\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE;\n          if (c === \"\\uFEFF\") {\n            continue;\n          }\n          beginWhiteSpace(parser, c);\n          continue;\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c);\n          continue;\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = charAt(chunk, i++);\n              if (c && parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else {\n                  parser.column++;\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n          if (c === \"<\" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, \"Text data outside of root node.\");\n            }\n            if (c === \"&\") {\n              parser.state = S.TEXT_ENTITY;\n            } else {\n              parser.textNode += c;\n            }\n          }\n          continue;\n        case S.SCRIPT:\n          // only non-strict\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else {\n            parser.script += c;\n          }\n          continue;\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n          continue;\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition;\n              c = new Array(pad).join(\" \") + c;\n            }\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n          continue;\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser, \"Inappropriately located doctype declaration\");\n            }\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else {\n            parser.sgmlDecl += c;\n          }\n          continue;\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n          parser.sgmlDecl += c;\n          continue;\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true; // just remember that we saw it.\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") {\n              parser.state = S.DOCTYPE_DTD;\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n          continue;\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n          continue;\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") {\n            parser.state = S.DOCTYPE;\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n          continue;\n        case S.COMMENT:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDING;\n          } else {\n            parser.comment += c;\n          }\n          continue;\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) {\n              emitNode(parser, \"oncomment\", parser.comment);\n            }\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n          continue;\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\");\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else {\n            parser.state = S.TEXT;\n          }\n          continue;\n        case S.CDATA:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING;\n          } else {\n            parser.cdata += c;\n          }\n          continue;\n        case S.CDATA_ENDING:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING_2;\n          } else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) {\n              emitNode(parser, \"oncdata\", parser.cdata);\n            }\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n        case S.PROC_INST:\n          if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY;\n          } else {\n            parser.procInstName += c;\n          }\n          continue;\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue;\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else {\n            parser.procInstBody += c;\n          }\n          continue;\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n          continue;\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else {\n            newTag(parser);\n            if (c === \">\") {\n              openTag(parser);\n            } else if (c === \"/\") {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, \"Invalid character in tag name\");\n              }\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n            parser.state = S.ATTRIB;\n          }\n          continue;\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n        case S.ATTRIB_NAME:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (c === \">\") {\n            strictFail(parser, \"Attribute without value\");\n            parser.attribValue = parser.attribName;\n            attrib(parser);\n            openTag(parser);\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE;\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (isWhitespace(c)) {\n            continue;\n          } else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\"\n            });\n            parser.attribName = \"\";\n            if (c === \">\") {\n              openTag(parser);\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue;\n          } else if (isQuote(c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB_VALUE_CLOSED;\n          continue;\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, \"No whitespace between attributes\");\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          if (c === \">\") {\n            openTag(parser);\n          } else {\n            parser.state = S.ATTRIB;\n          }\n          continue;\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue;\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += \"</\" + c;\n                parser.state = S.SCRIPT;\n              } else {\n                strictFail(parser, \"Invalid tagname in closing tag.\");\n              }\n            } else {\n              parser.tagName = c;\n            }\n          } else if (c === \">\") {\n            closeTag(parser);\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else if (parser.script) {\n            parser.script += \"</\" + parser.tagName;\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, \"Invalid tagname in closing tag\");\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n          continue;\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue;\n          }\n          if (c === \">\") {\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Invalid characters in closing tag\");\n          }\n          continue;\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState;\n          var buffer;\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT;\n              buffer = \"textNode\";\n              break;\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED;\n              buffer = \"attribValue\";\n              break;\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED;\n              buffer = \"attribValue\";\n              break;\n          }\n          if (c === \";\") {\n            if (parser.opt.unparsedEntities) {\n              var parsedEntity = parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n              parser.write(parsedEntity);\n            } else {\n              parser[buffer] += parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n            }\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c;\n          } else {\n            strictFail(parser, \"Invalid character in entity name\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n          continue;\n        default:\n          /* istanbul ignore next */{\n            throw new Error(parser, \"Unknown state: \" + parser.state);\n          }\n      }\n    } // while\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser);\n    }\n    return parser;\n  }\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode;\n      var floor = Math.floor;\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n        if (!length) {\n          return \"\";\n        }\n        var result = \"\";\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n          if (!isFinite(codePoint) ||\n          // `NaN`, `+Infinity`, or `-Infinity`\n          codePoint < 0 ||\n          // not a valid Unicode code point\n          codePoint > 0x10ffff ||\n          // not a valid Unicode code point\n          floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError(\"Invalid code point: \" + codePoint);\n          }\n          if (codePoint <= 0xffff) {\n            // BMP code point\n            codeUnits.push(codePoint);\n          } else {\n            // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xd800;\n            lowSurrogate = codePoint % 0x400 + 0xdc00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n        return result;\n      };\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, \"fromCodePoint\", {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n  return sax;\n};\nconst sax = /** #__PURE__ */initializeSax();\nexport { sax };"],
  "mappings": "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",
  "names": ["input", "options", "sax", "regex", "s", "uri"]
}
